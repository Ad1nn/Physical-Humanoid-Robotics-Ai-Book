---
sidebar_position: 4
---

# Chapter 1.2: Nodes, Topics & Services

## Deep Dive into ROS 2 Communication Patterns

In ROS 2, the true power of building complex robotic systems comes from how its various components communicate with each other. Unlike monolithic software, ROS 2 embraces a distributed architecture where small, modular programs (nodes) collaborate by exchanging information. Understanding these communication patterns is fundamental to designing robust and scalable robot applications.

ROS 2 provides several primary communication mechanisms, each suited for different types of data exchange:

1.  **Topics**: Used for continuous, asynchronous data streams (one-to-many communication). Ideal for sensor data, control commands, etc.
2.  **Services**: Used for request/response patterns (one-to-one communication). Ideal for triggering actions, querying state, etc.
3.  **Actions**: Built on services and topics, designed for long-running, goal-oriented tasks with feedback. (Will be covered in a later module).

These communication patterns are built on top of the Data Distribution Service (DDS) middleware, which we discussed in Chapter 1.1. DDS handles the low-level data transport, discovery, and Quality of Service (QoS) configurations, allowing ROS 2 developers to focus on the application logic.

In this chapter, we will explore Topics and Services in detail, learning how to implement them in Python using `rclpy`, and how to debug their interactions using ROS 2 command-line tools.

## Nodes: Autonomous Processes and Lifecycle

At the heart of every ROS 2 system are **nodes**. A node is simply an executable program that performs a specific, well-defined task within the robot's overall functionality. Think of them as individual applications or microservices running concurrently and communicating with each other.

### Key Characteristics of Nodes:

*   **Modularity**: Each node typically handles one logical unit of work (e.g., a camera driver, a motor controller, a navigation planner, an AI perception module). This modularity makes systems easier to design, debug, and maintain.
*   **Autonomy**: Nodes run independently of each other. They can be started, stopped, or restarted without affecting other nodes, as long as the communication interfaces are respected.
*   **Communication**: Nodes communicate by sending and receiving messages via various ROS 2 communication patterns (topics, services, actions).
*   **Naming**: Each node has a unique name within the ROS 2 graph. This name helps in identification and debugging.

### Node Lifecycle

Unlike ROS 1 where nodes were either running or not, ROS 2 introduces the concept of **managed node lifecycles**. This allows for a more robust and predictable startup, shutdown, and error handling of nodes, especially in critical applications.

A managed node can transition through several defined states:

1.  **Unconfigured**: The initial state of a newly created node.
2.  **Inactive**: The node is configured but not yet actively processing data or communicating.
3.  **Active**: The node is fully operational, publishing, subscribing, and performing its tasks.
4.  **Finalized**: The node is in the process of shutting down and cleaning up resources.

Transitions between these states (e.g., from `Unconfigured` to `Inactive` or `Inactive` to `Active`) can be triggered by external commands. This enables more sophisticated system management, such as bringing up a robot's components in a specific order or handling fault recovery. For simpler nodes, you might not explicitly manage the lifecycle, and they will typically start directly in an `Active`-like state.

In Python (`rclpy`), you create a node by inheriting from `rclpy.node.Node`, as seen in our "Hello World" example. This base class provides all the necessary functionalities for a node to integrate into the ROS 2 graph.

## Topics: The Publish/Subscribe Pattern

Topics are the most fundamental and frequently used communication mechanism in ROS 2. They implement a **publish/subscribe (pub/sub)** pattern, where nodes send (publish) messages to a named topic, and other nodes receive (subscribe) messages from that same topic.

### Key Concepts:

*   **Publisher**: A node that sends messages to a topic.
*   **Subscriber**: A node that receives messages from a topic.
*   **Topic Name**: A unique identifier for a stream of messages (e.g., `/cmd_vel`, `/odom`, `/scan`).
*   **Message Type**: The data structure of the messages being sent over a topic. ROS 2 provides a wide range of standard message types (e.g., `std_msgs/msg/String`, `geometry_msgs/msg/Twist`), and you can define custom ones.

### How it works:

Imagine a robot with a camera and a navigation system. The camera node would publish images to a topic named `/camera/image_raw`. The navigation system, needing visual input, would subscribe to `/camera/image_raw` to receive these images. Neither node needs to know about the other's existence directly; they only interact through the topic.

This decoupling is a powerful feature of ROS 2. Publishers and subscribers can be added or removed from the system dynamically without affecting other nodes, as long as they agree on the topic name and message type.

### Example Scenario:

*   A `sensor_node` publishes temperature data to the `/environment/temperature` topic (message type: `std_msgs/msg/Float32`).
*   A `display_node` subscribes to `/environment/temperature` to show the current temperature.
*   A `logger_node` also subscribes to `/environment/temperature` to record historical data.

All three nodes interact asynchronously via the topic, showcasing the one-to-many nature of the pub/sub pattern.

## Services: The Request/Response Pattern

While topics are excellent for continuous data streams, sometimes you need a direct, synchronous interaction between two nodes: one node makes a request, and another node provides a response. This is where **services** come into play, implementing a **request/response** pattern.

### Key Concepts:

*   **Service Server**: A node that offers a service. It waits for incoming requests and sends back responses.
*   **Service Client**: A node that calls a service. It sends a request and waits for a response.
*   **Service Name**: A unique identifier for a specific service offered (e.g., `/set_robot_pose`, `/get_battery_status`).
*   **Service Type**: Defines the structure of both the request and the response messages.

### How it works:

Consider a robot arm. You might have a `robot_arm_controller_node` that offers a service `/set_joint_angles`. A `user_interface_node` could be a client to this service, sending a request with desired joint angles. The `robot_arm_controller_node` receives the request, moves the arm, and then sends back a response indicating success or failure.

Unlike topics, which are asynchronous and broadcast messages, services are synchronous and point-to-point. A client sends a request and blocks (waits) until it receives a response from the server. This makes them suitable for tasks that require immediate feedback or an action to be completed before proceeding.

### Example Scenario:

*   A `navigation_node` needs to trigger a specific action (e.g., "stop moving"). It calls a `/robot/stop` service on the `base_controller_node`.
*   The `base_controller_node` executes the stop command and responds with `success: true`.
*   A `diagnostics_node` needs to query the current battery level. It calls a `/robot/get_battery` service on the `power_management_node`.
*   The `power_management_node` responds with `battery_level: 0.85`.

Services are crucial for implementing commands, queries, and other explicit interactions where a node needs to request a specific action or piece of information from another node and receive an immediate reply.

## Quality of Service (QoS) Settings

Quality of Service (QoS) is a powerful feature in ROS 2 that allows you to configure the communication behavior of topics and services to meet the specific needs of your application. DDS, the underlying middleware, offers a rich set of QoS policies that control aspects like reliability, durability, and message history.

### Why QoS is important:

*   **Reliability**: Guarantees message delivery, crucial for critical commands.
*   **Performance**: Optimize for high-throughput sensor data where some loss is acceptable.
*   **Flexibility**: Adapt communication to different network conditions and application requirements.
*   **Determinism**: Enhance predictability for real-time systems.

### Common QoS Policies:

1.  **History**: Determines how many messages are stored by the middleware.
    *   `KEEP_LAST`: Store a limited number of messages.
    *   `KEEP_ALL`: Store all messages (up to resource limits).
2.  **Durability**: Controls whether messages are persistent for late-joining subscribers.
    *   `VOLATILE`: Messages are not persistent; only active subscribers receive them.
    *   `TRANSIENT_LOCAL`: Publishers retain messages for new subscribers.
3.  **Reliability**: Guarantees message delivery.
    *   `BEST_EFFORT`: Messages may be lost (e.g., high-frequency sensor data).
    *   `RELIABLE`: Guarantees message delivery (e.g., critical commands).
4.  **Liveliness**: Detects if publishers are still active.
    *   `AUTOMATIC`: Liveliness is asserted automatically by the middleware.
    *   `MANUAL_BY_TOPIC`: Application explicitly asserts liveliness.
5.  **Deadline**: Specifies the expected maximum period between messages. If a publisher fails to send a message within this deadline, it can be detected.

### Configuring QoS in `rclpy`:

When creating a publisher or subscriber in `rclpy`, you can pass a `qos_profile` argument. This profile is an instance of `rclpy.qos.QoSProfile` or one of the predefined profiles (e.g., `qos_profile_sensor_data`, `qos_profile_system_default`).

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

class QoSExampleNode(Node):

    def __init__(self):
        super().__init__('qos_example_node')

        # Define a custom QoS Profile for a reliable publisher
        reliable_qos = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=5,  # Keep last 5 messages
            durability=DurabilityPolicy.TRANSIENT_LOCAL # Retain messages for new subscribers
        )

        # Create a publisher using the custom QoS profile
        self.publisher_ = self.create_publisher(String, 'qos_topic', qos_profile=reliable_qos)
        self.i = 0
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.get_logger().info('Reliable Publisher Node Started')

        # Create a subscriber using the system default QoS profile (often best effort)
        self.subscription = self.create_subscription(
            String,
            'qos_topic',
            self.listener_callback,
            rclpy.qos.qos_profile_sensor_data # Example: using a predefined profile for sensor data
        )
        self.get_logger().info('Sensor Data Subscriber Node Started')

    def timer_callback(self):
        msg = String()
        msg.data = f'Reliable Message: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}" with Reliable QoS')
        self.i += 1

    def listener_callback(self, msg):
        self.get_logger().info(f'Subscribing: "{msg.data}" with Sensor Data QoS')

def main(args=None):
    rclpy.init(args=args)
    node = QoSExampleNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

This code snippet demonstrates how to create a publisher with a custom reliable QoS profile and a subscriber with a predefined `qos_profile_sensor_data` (which is typically best-effort). By experimenting with different QoS settings, you can observe how message delivery changes, allowing you to optimize communication for various robotic scenarios.

## Exercise: Build a Sensor Data Pipeline (IMU → Processor → Visualizer)

This exercise challenges you to create a simple yet functional sensor data pipeline using ROS 2 topics. You will simulate an IMU (Inertial Measurement Unit) publishing data, process that data in another node, and then visualize it (conceptually).

### Goal:
Create a ROS 2 system that:
1.  **Simulates IMU data publishing**: A publisher node (`imu_publisher_node`) publishes `sensor_msgs/msg/Imu` messages to a topic (e.g., `/imu/data`) at a fixed rate. The messages should contain synthetic (random or incrementally changing) angular velocity and linear acceleration data.
2.  **Processes IMU data**: A subscriber node (`imu_processor_node`) subscribes to `/imu/data`, receives the messages, and performs a simple processing step. For example, it could calculate the magnitude of the linear acceleration or angular velocity and then republish this processed data to a new topic (e.g., `/imu/processed_data` with message type `std_msgs/msg/Float32`).
3.  **Visualizes processed data**: A subscriber node (`imu_visualizer_node`) subscribes to `/imu/processed_data` and simply logs the processed value to the console, simulating a basic visualization.

### Steps:

1.  **Define Custom Messages (if needed)**: While `sensor_msgs/msg/Imu` is standard, for the processed data, you might use `std_msgs/msg/Float32` or define a custom message type if the processed data is more complex.
2.  **Create ROS 2 Packages**: Create two new Python ROS 2 packages:
    *   `imu_sensor_package`: Will contain `imu_publisher_node`.
    *   `imu_pipeline_package`: Will contain `imu_processor_node` and `imu_visualizer_node`.
3.  **Implement `imu_publisher_node`**:
    *   Create a node that publishes `sensor_msgs/msg/Imu` messages.
    *   Populate the message fields with synthetic data (e.g., random numbers within a reasonable range for angular velocities and linear accelerations).
    *   Publish at a rate of 10 Hz.
4.  **Implement `imu_processor_node`**:
    *   Create a node that subscribes to `/imu/data`.
    *   In the callback, extract linear acceleration from the IMU message.
    *   Calculate the magnitude of the linear acceleration (e.g., `sqrt(x^2 + y^2 + z^2)`).
    *   Publish this magnitude to `/imu/processed_data` as a `std_msgs/msg/Float32` message.
5.  **Implement `imu_visualizer_node`**:
    *   Create a node that subscribes to `/imu/processed_data`.
    *   In the callback, simply log the received float value to the console.
6.  **Update `setup.py` files**: Add entry points for all your nodes in their respective `setup.py` files.
7.  **Build your workspace**: Use `colcon build --packages-select imu_sensor_package imu_pipeline_package`.
8.  **Source your workspace**.
9.  **Run the pipeline**:
    *   In three separate terminals (or using `ros2 launch` if you create a launch file):
        ```bash
        ros2 run imu_sensor_package imu_publisher_node
        ros2 run imu_pipeline_package imu_processor_node
        ros2 run imu_pipeline_package imu_visualizer_node
        ```

### Expected Output:

You should observe the `imu_publisher_node` logging published IMU data, the `imu_processor_node` logging its processing steps, and the `imu_visualizer_node` logging the processed float values. You can also use `ros2 topic echo /imu/data` and `ros2 topic echo /imu/processed_data` to inspect the data flow.

This exercise will give you hands-on experience in building a multi-node, multi-topic ROS 2 system, demonstrating the power of modular communication pipelines.

## Debugging with `ros2 CLI` Tools

Effective debugging is crucial for any complex system, and ROS 2 provides a powerful set of command-line interface (CLI) tools to inspect, monitor, and troubleshoot your robot applications. These tools allow you to peek into the ROS 2 graph and understand what's happening under the hood.

Here are some essential `ros2 CLI` commands you'll use frequently:

1.  **`ros2 node list`**:
    *   **Purpose**: Lists all active ROS 2 nodes currently running in your system.
    *   **Usage**: `ros2 node list`
    *   **Tip**: Use `ros2 node info <node_name>` to get detailed information about a specific node (e.g., its publishers, subscribers, services, actions).

2.  **`ros2 topic list`**:
    *   **Purpose**: Lists all active topics being published or subscribed to.
    *   **Usage**: `ros2 topic list`
    *   **Tip**: Use `ros2 topic list -t` to also display the message types for each topic. `ros2 topic info <topic_name>` provides more details about a specific topic.

3.  **`ros2 topic echo <topic_name>`**:
    *   **Purpose**: Displays the messages being published on a specific topic in real-time. This is invaluable for verifying if data is being sent correctly.
    *   **Usage**: `ros2 topic echo /chatter`
    *   **Tip**: Press `Ctrl+C` to stop echoing messages.

4.  **`ros2 service list`**:
    *   **Purpose**: Lists all active services being offered by nodes.
    *   **Usage**: `ros2 service list`
    *   **Tip**: Use `ros2 service list -t` to also display the service types. `ros2 service info <service_name>` provides details about a specific service.

5.  **`ros2 service call <service_name> <service_type> <request_arguments>`**:
    *   **Purpose**: Calls a ROS 2 service from the command line. This is extremely useful for testing services without writing a client node.
    *   **Usage**: `ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 1, b: 2}"`
    *   **Tip**: You need to provide the service name, service type, and the request arguments in YAML format.

6.  **`ros2 param list`**:
    *   **Purpose**: Lists all parameters declared by ROS 2 nodes.
    *   **Usage**: `ros2 param list`
    *   **Tip**: Use `ros2 param get <node_name> <param_name>` and `ros2 param set <node_name> <param_name> <value>` to inspect and modify parameters.

### Practical Debugging Workflow:

1.  **Start your nodes**: Run all your ROS 2 nodes.
2.  **Inspect nodes**: Use `ros2 node list` to confirm all intended nodes are running.
3.  **Inspect topics**: Use `ros2 topic list` to see if all expected topics are active. Use `ros2 topic info <topic_name>` to check publishers/subscribers and message types.
4.  **Monitor data flow**: Use `ros2 topic echo <topic_name>` to verify that messages are being published and contain the correct data.
5.  **Test services**: Use `ros2 service list` and `ros2 service call` to interact with your services and check their responses.
6.  **Check logs**: ROS 2 nodes log messages to the console and often to `~/.ros/log`. Monitor these for errors or warnings.

By mastering these `ros2 CLI` tools, you will significantly speed up your development and debugging process for ROS 2 applications.




